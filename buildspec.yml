version: 0.2

env:
  variables:
    IMAGE_TAG: latest
    DEPLOYMENT_NAMESPACE: default
    AWS_DEFAULT_REGION: ap-south-1
    CLUSTER_NAME: hts-usecase-cluster

phases:
  pre_build:
    commands:
      - echo Logging into Amazon ECR...
      - aws ecr get-login-password --region $AWS_DEFAULT_REGION | docker login --username AWS --password-stdin $ECR_REPO_URI
      - REPO_IMAGE="$ECR_REPO_URI:$IMAGE_TAG"

  build:
    commands:
      - echo Building Docker image...
      - docker build -t $APP_NAME .
      - docker tag $APP_NAME:latest $REPO_IMAGE

  post_build:
    commands:
      - echo Pushing Docker image to ECR...
      - docker push $REPO_IMAGE

      - echo Updating kubeconfig for EKS cluster...
      - aws eks update-kubeconfig --region $AWS_DEFAULT_REGION --name $CLUSTER_NAME

      - echo Verifying EKS access...
      - |
        if ! aws eks describe-cluster --name $CLUSTER_NAME --region $AWS_DEFAULT_REGION; then
          echo "ERROR: CodeBuild role cannot access the cluster. Attach proper IAM permissions."
          exit 1
        fi
        echo "EKS access verified ✅"

      - echo Creating Kubernetes deployment manifest...
      - |
        cat <<EOF > deployment.yaml
        apiVersion: apps/v1
        kind: Deployment
        metadata:
          name: ${APP_NAME}
          labels:
            app: ${APP_NAME}
        spec:
          replicas: 1
          selector:
            matchLabels:
              app: ${APP_NAME}
          template:
            metadata:
              labels:
                app: ${APP_NAME}
            spec:
              containers:
              - name: ${APP_NAME}
                image: ${REPO_IMAGE}
                ports:
                - containerPort: 8000
        ---
        apiVersion: v1
        kind: Service
        metadata:
          name: ${APP_NAME}
          annotations:
            service.beta.kubernetes.io/aws-load-balancer-type: "alb"
            service.beta.kubernetes.io/aws-load-balancer-scheme: "internet-facing"
        spec:
          type: LoadBalancer
          ports:
            - port: 80
              targetPort: 8000
          selector:
            app: ${APP_NAME}
        EOF

      - echo Applying manifest to EKS...
      - kubectl apply -f deployment.yaml -n $DEPLOYMENT_NAMESPACE --validate=false

      - echo Waiting for pods to be ready...
      - |
        for i in {1..30}; do
          READY=$(kubectl get pods -n $DEPLOYMENT_NAMESPACE -l app=$APP_NAME -o jsonpath='{.items[*].status.containerStatuses[*].ready}')
          if [[ "$READY" == "true" ]]; then
            echo "Pods are ready ✅"
            break
          else
            echo "Waiting for pods..."
            sleep 10
          fi
        done

      - echo Waiting for LoadBalancer hostname...
      - |
        for i in {1..60}; do
          HOSTNAME=$(kubectl get svc $APP_NAME -n $DEPLOYMENT_NAMESPACE -o jsonpath='{.status.loadBalancer.ingress[0].hostname}')
          if [ -n "$HOSTNAME" ]; then
            echo "ALB Hostname: $HOSTNAME"
            echo "Your app is live at http://$HOSTNAME"
            break
          else
            echo "Waiting for LoadBalancer..."
            sleep 10
          fi
        done

      - echo Deployment complete ✅
      - echo "Final Kubernetes resources:"
      - kubectl get deployments,pods,svc -n $DEPLOYMENT_NAMESPACE

artifacts:
  files:
    - '**/*'
