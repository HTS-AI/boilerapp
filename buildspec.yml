version: 0.2

env:
  variables:
    IMAGE_TAG: latest
    DEPLOYMENT_NAMESPACE: default   # Change if using a different namespace
    CONTAINER_PORT: 8000
    SERVICE_PORT: 80

phases:
  pre_build:
    commands:
      - echo Logging into Amazon ECR...
      - aws ecr get-login-password --region $AWS_DEFAULT_REGION | docker login --username AWS --password-stdin $ECR_REPO_URI
      - REPO_IMAGE="$ECR_REPO_URI:$IMAGE_TAG"

  build:
    commands:
      - echo Building Docker image...
      - docker build -t $APP_NAME .
      - docker tag $APP_NAME:latest $REPO_IMAGE

  post_build:
    commands:
      - echo Pushing image to ECR...
      - docker push $REPO_IMAGE

      - echo Updating kubeconfig for EKS cluster...
      - aws eks update-kubeconfig --region $AWS_DEFAULT_REGION --name $CLUSTER_NAME

      - echo Verifying EKS access...
      - |
        if ! kubectl get nodes; then
          echo "ERROR: CodeBuild role cannot access the cluster. Attach proper IAM permissions."
          exit 1
        fi
        echo "EKS access verified ✅"

      - echo Creating Kubernetes deployment manifest...
      - cat <<EOF > deployment.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: ${APP_NAME}
  labels:
    app: ${APP_NAME}
spec:
  replicas: 1
  selector:
    matchLabels:
      app: ${APP_NAME}
  template:
    metadata:
      labels:
        app: ${APP_NAME}
    spec:
      containers:
      - name: ${APP_NAME}
        image: ${REPO_IMAGE}
        ports:
        - containerPort: ${CONTAINER_PORT}
---
apiVersion: v1
kind: Service
metadata:
  name: ${APP_NAME}
  annotations:
    service.beta.kubernetes.io/aws-load-balancer-type: "alb"
    service.beta.kubernetes.io/aws-load-balancer-scheme: "internet-facing"
spec:
  type: LoadBalancer
  ports:
    - port: ${SERVICE_PORT}
      targetPort: ${CONTAINER_PORT}
  selector:
    app: ${APP_NAME}
EOF

      - echo Applying manifest to EKS...
      - kubectl apply -f deployment.yaml -n $DEPLOYMENT_NAMESPACE --validate=false

      - echo Waiting for pods to be ready...
      - |
        for i in {1..30}; do
          READY=$(kubectl get pods -n $DEPLOYMENT_NAMESPACE -l app=$APP_NAME -o jsonpath='{.items[*].status.containerStatuses[*].ready}')
          if [[ "$READY" == "true" ]]; then
            echo "Pods are ready ✅"
            break
          else
            echo "Waiting for pods..."
            sleep 10
          fi
        done

      - echo Waiting for LoadBalancer hostname...
      - |
        for i in {1..60}; do
          HOSTNAME=$(kubectl get svc $APP_NAME -n $DEPLOYMENT_NAMESPACE -o jsonpath='{.status.loadBalancer.ingress[0].hostname}')
          if [ -n "$HOSTNAME" ]; then
            echo "ALB Hostname: $HOSTNAME"
            echo "You can now access your app at http://$HOSTNAME"
            break
          else
            echo "Waiting for LoadBalancer..."
            sleep 10
          fi
        done

      - echo Deployment complete ✅
      - echo "Final resource status:"
      - kubectl get deployments,pods,svc -n $DEPLOYMENT_NAMESPACE

artifacts:
  files:
    - '**/*'
